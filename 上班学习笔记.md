学习：kafak es vue

回表
UUID 和 ‌自增主键  雪花id
表设计
数据被误删
undo.log 和 redo.log
SQL执行顺序
大字段建索引
索引失效
三层B+树
事务的二阶段提交
逻辑、物理删除
逻辑、物理外键
聚簇索引与非聚簇索引
InnoDB 与 MyISAM
EXPLAIN分析
优化器如何选择执行计划
Redis 与 MySQL 数据一致性
生产环境MySQL事务隔离级别推荐
WAL机制
数据库性能优化方法
Exists和in区别
什么情况不推荐建索引
什么是数据库游标
什么是数据库视图
MySQL中 存金额应该用什么数据类型
MySQL中 常用的函数有哪些
数据库的三大范式是什么： 每列不可再分的最小数据单元‌、所有非主属性必须完全依赖主键‌、非主属性不能传递依赖于主键
DateTime 和 TimeStamp类型区别：范围 时区 自动更新
MySQL中 Limit 100000000,10 和 Limit 10 的执行速度是否相同： 扫描数量  I/O和cup消耗
MySQL中 Inner Join 、Left Join 、Right Join 区别是什么
MySQL中 delete  truncate trop 的区别是什么：作用范围  事务支持  执行速度   自增重置
MySQL中 如何监控和优化慢SQL ： 启用慢查询日志、EXPLAIN 分析执行计划；索引优化、查询优化、服务器参数调优
MySQL中 如何解决深度分页的问题：延迟关联(子查询+覆盖索引快速定位目标数据)、游标分页(有序唯一键)、索引优化(使用联合索引避免回表)
MySQL中 为什么不推荐使用多表Join：查询复杂度增加、内存与CPU‌消耗增加、临时表溢出；索引优化、SQL拆分、冗余关键字段
MySQL中 Log Buffer是什么，有什么作用：内存缓冲区；临时存储事务产生Redo Log，批量写入磁盘；
MySQL中 覆盖索引是什么：查询字段被索引包含，无需回表
MySQL中 索引下推(即ICP)是什么：将WHERE条件非索引字段过滤操作提前到存储引擎层执行;减少回表次数
Spring 什么是循环依赖？如何解决循环依赖：两个或多个 Bean 相互引用对方；三级缓存机制‌ 解决 ‌单例 Bean 的属性注入（无法解决构造器注入）‌ 循环依赖
SpringBoot 是什么：基于 Spring 框架的快速开发工具‌；自动配置、内嵌服务器、‌Starter 预置依赖(自动集成所有相关依赖)
SpringBoot 启动过程：启动入口(调用主启动类的SpringApplication.run()方法)、初始化配置(推断是Web、Reactive 或普通应用类型；加载 spring.factories 中的配置类、监听器)、
            环境准备(加载配置源：命令行参数、配置文件、环境变量等；激活环节配置：开发、测试、生产环境‌)、应用上下文创建(根据应用类型创建对应的上下文对象)、
            刷新上下文(加载 Bean定义：注解 ;加载并过滤 spring.factories 中的自动配置类;启动内嵌服务器;实例化单例 Bean)、完成启动
Spring 启动过程：容器初始化(加载Bean配置文件、扫描Bean注解)、加载Bean定义(解析配置：读取配置文件的 <bean> 定义、扫描容器化管理注解；‌注册到容器：将 Bean 的元信息（如类名、作用域、依赖）存储到容器)、
                处理扩展点(替换 ${} 占位符为实际值、插入AOP 代理)、实例化 Bean(创建对象、依赖注入、初始化回调)、容器就绪
Spring Bean的生命周期：实例化(创建对象) → 属性注入(依赖注入:字段、构造方法、setter) → 前置处理(在初始化方法执行前) → 初始化(@PostConstruct 注解标记的方法) → 后置处理(在初始化方法执行后) → 就绪 → 销毁 (@PreDestroy 注解标记的方法)
说说Java中 HashMap 的原理：特点、结构、插入原理、扩容机制、红黑树结构特点：根黑色、叶子黑色、红色的子节点为黑色、插入默认为红色、旋转重着色
Java中 ConcurrentHashMap如何实现线程安全：空桶(CAS)、非空桶(头节点加 synchronized 锁)
Java中有哪些集合类: List(ArrayList、LinkedList、CopyOnWriteArrayList) Set(HashSet‌、LinkedHashSet‌、TreeSet‌、CopyOnWriteArraySet) HashMap(HashMap‌、LinkedHashMap‌、TreeMap‌、ConcurrentHashMap)
MySQL中 索引类型有哪些:存储方式(聚簇/非聚簇) 字段个数(单列/联合) 字段特性(主键/唯一/普通/前缀)
数据库中的脏读 不可重复读 幻读 分别是什么？使用什么隔离级别避免
MySQL中 使用索引一定有效吗？如何排查索引是否有效：索引失效的7种情况；Explain 慢SQL日志
死信交换机：用于接收“死信”的专用交换机，通过死信交换机重新路由到死信队列(死信：消息被明确拒绝/消息过期/队列容量超限)
RabbitMQ 如何实现延迟队列：死信交换机+TTL(队列设置：死信交换机+死信路由key+TTL—>消息过期-> 路由到延迟队列->消费者监听延迟队列)
延迟队列：延迟执行的任务或消息(RabbitMQ的死信交换机+消息TTL；Redis的Sorted Set的Score作为过期时间)
MySQL中 索引数量是否越多越好：写操作性能降低  存储和维护成本增加  冗余索引 无效索引  优化器时间增加
MySQL中 详细讲解B+树中查询数据的全过程


===========================================微服务=======================================
Eureka：服务注册与发现（服务提供者启动向Eruka注册自身信息服务名称、ip、端口；消费者通过服务名称从Eruka获取可用的服务列表）、负载均衡（消费者结合Ribbon组件，基于轮询、随机、权重等算法选择服务） 故障迁移与容错（通过心跳检查服务健康状态，剔除不可以服务；Eureka宕机可使用本地缓存服务信息通信） 自我保护（因网络原因导致多数服务心跳检测异常，Eureka会暂停剔除服务，避免误删）

Eureka Service搭建（建项目、引Eureka Service依赖、改yml配置、主启动类加@EnableEurekaService）  Eureka Client搭建（建项目、引Eureka Client依赖、改yml配置、主启动类加@EnableEurekaService @EnableDiscoveryCilent  Ribbon远程调用）

CAP原则：Consistency（一致性）  Availability（可用性） Partition Tolerance（网络分区容错性）；在分布式系统中，必须接受网络分区（节点间通信中断）不可靠的现实‌，因此系统设计时‌只能在一致性（C）和可用性（A）之间二选一‌

Eureka:		AP原则			对等节点，去中心化			较慢剔除(90s)		适用高可用优先的微服务（最终一致）
Zookeeper:	CP原则			主从模式，Leader选举		快速剔除			强一致性优先、分布式协调的微服务
Consul:		CP原则			Raft协议					较快剔除			多云治理、复杂服务网格的微服务
Nacos:		CP/AP可切换		混合架构，灵活模式切换		AP慢，CP快		动态服务与配置一体化管理的微服务
Raft协议:‌是一种用于分布式系统中的一致性算法，旨在确保多个节点在面对节点故障或网络分区时仍能保持数据一致性

Zookeeper 部署在Linux上   Consul下载解压后开发模式启动  Nacos下载解压后单机模式启动
Consul注册中心接入：建项目、引consul-discovery依赖、改yaml(服务注册)、主启动类加@EnableDiscoveryClient注解、Controller（使用RestTemplate或OpenFeign服务调用）；开发模式快速启动(consul agent -dev -client=0.0.0.0 -ui)  再启动注册的服务
Nacos注册中心接入：建项目、引nacos-discovery依赖、改yaml(服务注册、配置中心启用)、主启动类加@EnableDiscoveryClient注解、Controller（使用RestTemplate或OpenFeign服务调用、@Value("${}")获取配置内容）；开发模式快速启动(startup.cmd -m standalone)  再启动注册的服务；使用namespace隔离开发、测试、生产环境配置参数
Apollo配置中心接入：建项目、引apollo-client依赖、改yml(配Apollo连接信息id host namespace)、主启动类加@EnableApolloConfig注解、Controller（使用@Value("${}")获取配置内容,自动更新需配合@RefreshScope使用）；下载并解压，启动(startup.cmd  )，再服务；使用namespace隔离开发、测试、生产环境配置参数；敏感信息加密存储‌

Zuul网关接入：建项目、引zuul依赖、改yml(配路由规则)、主启动类加@EnableZuulProxy注解、继承ZuulFilter（重新run方法请求拦截、鉴权）；

Consul		下载解压后，开发者模式启动
Provider	搭项目、引pom(consul-discovery)、改yml(服务端口 服务名称 consul注册)   主启动(服务注册与发现注解：@EnableDiscoveryClient)	Controller
Zuul 		搭项目、引pom(zuul)、改yml(服务端口 服务名称 consul注册 路由代理配置)	主启动(启用Zuul网关代理@EnableZuulProxy 服务注册与发现注解：@EnableDiscoveryClient)   继承 ZuulFilter(请求拦截、鉴权)
Consumer	搭项目、引pom(consul-discovery)、改yml(服务端口 服务名称 consul注册)   主启动(服务注册与发现注解：@EnableDiscoveryClient)	Controller(继承调用中间件ribbon openFeign)

自定义zuul拦截：重写ZuulFilter的run()方法；获取当前请求内容，根据请求URI判断是否属于白名单，是就放行；否则，对请求token进行有效性校验并解析，获取用户信息，检查token是否需要续期；重新封装请求头信息



@Transactional失效情况：
注解未使用public修饰方法(AOP默认代理public修饰的方法)
同类内部调用会绕过代理（同一个类中，非注解方法调用注解方法； 可以通过在本类中创建对象 通过对象调用方法）
@Transactional方法中使用try-catch捕获异常，且不在catch中抛出异常（要么不使用try-catch,要么在catch中抛出异常）




