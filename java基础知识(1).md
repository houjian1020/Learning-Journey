#java学习路线

一、基础知识面试题

1、Jdk和Jre和JVM的区别
    jdk除了包含jre 还包含java开发工具
    jre除了包含jvm 还包含了运行java程序所需的类库（可以保障程序运行）
    jvm即java虚拟机 不同操作系统有自己的虚拟机，通过虚拟机可以实现跨平台

2、什么是跨平台性？原理是什么？
    跨平台：一次编译后的程序可以在 不同的平台运行（一次编译，多处运行）
    原理： 不同平台的java虚拟机 可以将class文件转译对应系统的机器码

3、Java语言有哪些特点?
    面向对象（封装 继承 多态）    平台无关（jvm）    支持多线程   支持网络编程

4、什么是字节码？采用字节码的最大好处是什么？
    字节码：后缀为.class的文件 不面向任何系统 只面向虚拟机
    好处：可跨平台
    编译器：将java文件编译为.class文件
    解释器：将.class文件翻译为机器码

5、应用程序和小程序的区别
    应用程序：从主线程启动(也就是main()方法)
    小程序：  没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)

6、Java和C++的区别
    java没有指针  java单继承  java内存自动回收

~~7、 Oracle JDK 和 OpenJDK 的对比、
    发布频率 全开源半开源 更稳定~~

8、Java有哪些数据类型？
    八大基本数据类型: byte short int long   float double  char  boolean
    引用数据类型：数组、类、接口

9、用最有效率的方法计算 2 乘以 8
    2 << 3（左移 3 位相当于 2 乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。
    00000010  00010000 
    2       16       2 乘以2 的 3次方 
    00000011  00011000 
    3       24       3 乘以2 的 3次方   

10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少
    Math.round(11.5) ： 四舍五入为12
    Math.round(-11.5)： 四舍五入为：-11  （四舍五入的原理是在参数 上加 0.5 然后 向下 取整）

11、float f=3.4;是否正确
    不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型，会造成精度损失

12、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？
    有错：由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型
    无错：因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。

13、Java语言采用何种编码方案
    Unicode编码


14、访问修饰符 public,private,protected,以及不写（默认）时的区别  
    private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）
    default : 在同一包内可见。(即缺省） 使用对象：类、接口、变量、方法。
    protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类 （外部类）。
    public : 对所有类可见。使用对象：类、接口、变量、方法

15、&和&&的区别
    &运算符： 按位与
    &&运算符：是短路与运算

16、final 有什么用？
    被final修饰的类：   不可以被继承
    被final修饰的方法： 不可以被重写
    被final修饰的变量： 不可以被改变，（不可变的是变量的引用，内容是可以改变的）

17、final finally finalize区别
    final修饰类、变量、方法
    finally异常处理时使用（finally代码块不管是否出现异常都会执行，一般存放一些关闭资源的代码）
    finalize()是Object类的回收垃圾方法（当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize())

18、this super关键字的用法
    普通的直接引用
    形参与成员名字重名，用this来区分
    引用本类的构造函数

19、this与super的区别
    super: 当前对象的直接父类
    this：代表当前对象名
    this()：在本类构造方法调用其它构造方法（不能调用两个）  
    super()：在子类中调用父类的构造方法(this和super不能同时出现在一个构造函数里面)
    均不可以在static环境中使用

20、static特点
    共享：被static修饰的变量或者方法被类对象所共享。
    加载：类被第一次加载的时候，就会加载static修饰的部分，并分配空间
    调用：没有创建对象，也可以去访问（被static修饰的变量或者方法是优先于对象存在的）
    注意事项：静态只能访问静态；非静态既可以访问非静态的，也可以访问静态的

21、break ,continue ,return 的区别及作用
    break：结束当前的循环体
    continue：结束正在执行的循环 进入下一个循环条件
    return：结束当前的方法 直接返回


22、面向对象三大特性
    封装：不想给外界访问的属性、方法私有化
    继承：拥有父类非 private 的属性和方法（复用性）  拥有自己属性和方法（扩展性）  用自己的方式实现父类的方法（扩展性）
    多态：多个子类对同一方法的重写（继承）和 实现接口并重写  接口中同一方法（接口）


23、实现多态有三个必要条件
    继承  重写  向上转型


24、抽象类和接口的对比
    相同点：
        不能通过new实例化;
        都包含抽象方法，且子类都必须覆写
    不同点：
        声明关键字：抽象类使用abstract关键字声明；接口使用interface关键字声明
        继承或实现关键字：子类使用extends关键字来继承抽象类；子类使用implements关键字来实现接口
        方法修饰符：抽象类中的方法可以是任意访问修饰符；接口方法默认修饰符是public
        单继承/多实现：一个类只能继承一个抽象类；个类可以实现多个接口
        属性修饰符：抽象类的属性声明可以是任意的；接口的属性默认都是 static 和 final的
        构造器：抽象类可以有构造器；接口不能有构造器


25、普通类和抽象类有哪些区别
    普通类：不能包含抽象方法
    抽象类：不能直接实例化



26、创建一个对象用什么关键字？对象实例与对象引用有何不同？
    关键字：new
    对象实例：new创建对象实例，堆内存中
    对象引用：指向对象实例，栈内存中


27、在Java中定义一个不做事且没有参数的构造方法的作用
    如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误。


28、一个类的构造方法的作用是什么？
    完成对类对象的初始化工作

29、构造方法有哪些特性？
    名字与类名相同
    没有返回值
    创建对象时自动执行，无需调用


30、成员变量与局部变量的区别有哪些？
    代码位置:   类内部     方法或代码块
    作用域：    整个类     方法或代码块
    存储位置:   堆内存中    栈内存中  
    生命周期:   随着对象的创建而存在，随着对象的消失而消失      当方法/代码块调用时存在，当方法/代码块调用完，就自动释放
    初始值：    有默认初始值      没有默认初始值


31、静态变量和实例变量区别
    静态变量：属于类（对象共享），在类的加载过程中，JVM只分配一次内存空间
    实例变量：属于对象，每次创建对象，都会为分配内存空间


32、什么是内部类？
    定义：将一个类放到另外一个类的内部，内部类本身就是类的一个属性
    分类：成员内部类、局部内部类、静态内部类、匿名内部类（匿名内部类必须继承或实现一个已有的接口）

35、内部类的优点
    访问私有：可以访问外部类对象的内容，包括私有数据
    封装性：同一包的其他类不可见
    多重继承：内部类有效实现了“多重继承”，优化 java 单继承的缺陷


36、重载（Overload）和重写（Override）的区别？
    方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，后者实现的是运行时的多态性
    重载：同一个类中，方法名相同参数列表不同，与方法返回值和访问修饰符无关
    重写：父子类中，方法名、参数列表必须相同，访问修饰符大于等于父类（里氏代换原则；如果父类方法访问修饰符为private则子类中就不是重写）


37、== 和 equals 的区别是什么？
    == ：基本数据类型比较的是值，引用数据类型比较的是内存地址
    equals()： equals()没有被重写 和 “==” 相同

38、hashCode()与equals()的相关规定
    两个对象相等，则hashcode一定也是相同的
    两个对象相等，对两个对象分别调用equals方法都返回true
    两个对象有相同的hashcode值，它们也不一定是相等的


39、为什么重写equals时必须重写hashCode方法？
    因为违背了38中的规定


40、对象的相等与指向他们的引用相等，两者有什么不同？
    对象相等：比的是内存中存放的内容是否相等 
    引用相等：比较的是他们指向的内存地址是否相等


41、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？
    是值传递。Java 语言的方法调用只支持参数的值传递。
    原因：传递的是对象引用的值（这时相当于两个引用指向堆内存中的同一个对象）


42、JDK 中常用的包有哪些？
    java.lang：这个是系统的基础类；
    java.util：这个是系统辅助类，特别是集合类；
    java.io：这里面是所有输入输出有关的类，比如文件操作等；
    java.net：这里面是与网络有关的类；
    java.sql：这个是数据库操作的类
    java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；


43、java 中 IO 流分为几种?
    按照流的流向分：输入流和输出流
    按照操作单元划分：字节流和字符流
    按照流的角色划分：节点流和处理流
    InputStream/Reader: 所有的输入流的基类
    OutputStream/Writer: 所有输出流的基类

44、BIO,NIO,AIO 有什么区别?
    BIO：BlockIO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
    NIO：NonIO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
    AIO：AsynchronousIO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步IO的操作基于事件和回调机制


45、Files的常用方法都有哪些？
    Files. exists()：检测文件路径是否存在。
    Files. createFile()：创建文件。
    Files. createDirectory()：创建文件夹。
    Files. delete()：删除一个文件或目录。
    Files. copy()：复制文件。
    Files. move()：移动文件。
    Files. size()：查看文件个数。
    Files. read()：读取文件。
    Files. write()：写入文件


46、 什么是反射机制？
    定义：运行状态中，能获取这个类的属性和方法；能调用对象的属性和方法
    优点：提高代码灵活度
    缺点：性能慢


47、反射机制的应用场景有哪些？
    JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序
    Spring框架也用到很多反射机制，最经典的就是xml的配置模式

48、Java获取反射的三种方法
    通过对象方法实现反射机制:new Student().getClass()
    通过类路径实现反射机制:Class.forName("fanshe.Student")
    通过类名实现反射机制:Student.class


49、字符型常量和字符串常量的区别？
    形式上:单引号 双引号
    含义上:相当于一个整形值(ASCII值)   地址值
    内存上：2个字节    取决于字符串长度


50、什么是字符串常量池？
    用来存储字符串常量，提高内存使用率（在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。）


51、String有哪些特性？
    不变性：对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。
    常量池优化：在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。
    final：不能被继承，提高了系统的安全性


51、String真的是不可变的吗？
    不可变：String不可变但不代表引用不可以变
    底层：private final char value[]
    本质：分配到常量池中


52、String str="i"与 String str=new String(“i”)一样吗？
    不一样：String str="i"的方式，虚拟机会将其分配到常量池中； 而 String str=new String(“i”) 则会被分到堆内存中


53、String s = new String(“xyz”);创建了几个字符串对象？
    两个对象：一个是常量池的"xyz"，一个是用new创建在堆上的对象。


54、数组有没有 length()方法？String 有没有 length()方法？
    数组：length 的属性
    String： length()方法

55、String 类的常用方法都有那些？
    indexOf()：返回指定字符的索引
    charAt(1)：返回指定索引处的字符
    replace("aaa")：字符串替换
    trim()：去除字符串两端空白
    split()：分割字符串，返回一个分割后的字符串数组
    getBytes()：返回字符串的 byte 类型数组
    length()：返回字符串长度
    toLowerCase()：将字符串转成小写字母
    toUpperCase()：将字符串转成大写字符
    substring()：截取字符串
    equals()：字符串比较


56、在使用 HashMap 的时候，用 String 做 key 有什么好处？
    存储更快：字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算


57、String和StringBuffer、StringBuilder的区别是什么？
    String：字符串常量；通常用于操作少量的数据；该类有final修饰
    StringBuffer：字符串变量；通常用于操作大量数据；该类有final修饰；线程安全
    StringBuilder：字符串变量；通常用于操作大量数据；该类有final修饰；非线程安全，速度更快建议使用


58、自动装箱与拆箱
    装箱：将基本类型用它们对应的引用类型包装起来
    拆箱：将包装类型转换为基本数据类型
    原始类型: boolean，char，byte，short，int，long，float，double
    包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

59、Integer a= 127 与 Integer b = 127相等吗?
    相等：如果整型字面量的值在-128到127之间，直接引用常量池中的Integer对象
    对于对象引用类型：==比较的是对象的内存地址。
    对于基本数据类型：==比较的是值。